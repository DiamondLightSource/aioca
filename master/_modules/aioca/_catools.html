<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>aioca._catools &mdash; aioca 1.3+6.g6f1658a documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: rgb(7, 43, 93)" >
            <a href="../../contents.html" class="icon icon-home"> aioca
          </a>
              <div class="version">
                master
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
  
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Introduction</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">aioca API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/dls-controls/aioca/blob/master/CHANGELOG.rst">Changelog</a></li>
<li class="toctree-l1"><a class="reference external" href="genindex.html#http://">Index</a></li>
</ul>

  <!-- Add versions for selected branches + tags -->
  <p class="caption">
    <span class="caption-text">Versions</span>
  </p>
  <ul id="versions"/>
  <script>
    // Add any branches to appear in the side pane here, tags will be added below
    // Will only appear if docs are built and pushed in gh-pages
    var versions = ['main', 'master'];
    var dirs = new Set();
    function addVersion(name) {
      if (dirs.has(name)) {
        var li = document.createElement("li");
        var a = document.createElement("a");
        a.href = 'https://dls-controls.github.io/aioca/' + name;
        a.innerText = name;
        li.appendChild(a)
        document.getElementById('versions').appendChild(li);
      }
    }
    Promise.all([
      // Find gh-pages directories and populate `dirs`
      fetch("https://api.github.com/repos/dls-controls/aioca/contents?ref=gh-pages")
      .then(response => response.json())
      .then(data => data.forEach(function(e) {
        if (e.type == "dir") dirs.add(e.name);
      })),
      // Add tags to `versions`
      fetch('https://api.github.com/repos/dls-controls/aioca/tags')
        .then(response => response.json())
        .then(data => data.forEach(function(e) {
          versions.push(e.name);
        }))
      ]).then(_ => versions.forEach(addVersion))
  </script>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: rgb(7, 43, 93)" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../contents.html">aioca</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../contents.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>aioca._catools</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for aioca._catools</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">atexit</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Awaitable</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Deque</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Generic</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">epicscorelibs.ca</span> <span class="kn">import</span> <span class="n">cadef</span><span class="p">,</span> <span class="n">dbr</span>

<span class="kn">from</span> <span class="nn">.types</span> <span class="kn">import</span> <span class="n">AugmentedValue</span><span class="p">,</span> <span class="n">Count</span><span class="p">,</span> <span class="n">Datatype</span><span class="p">,</span> <span class="n">Dbe</span><span class="p">,</span> <span class="n">Format</span><span class="p">,</span> <span class="n">Timeout</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
<span class="n">PVs</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>

<span class="n">DEFAULT_TIMEOUT</span> <span class="o">=</span> <span class="mf">5.0</span>


<span class="k">class</span> <span class="nc">ValueEvent</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>


<div class="viewcode-block" id="CANothing"><a class="viewcode-back" href="../../api.html#aioca.CANothing">[docs]</a><span class="k">class</span> <span class="nc">CANothing</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This value is returned as a success or failure indicator from `caput`,</span>
<span class="sd">    as a failure indicator from `caget`, and may be raised as an exception to</span>
<span class="sd">    report a data error on caget or caput with wait.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">errorcode</span><span class="o">=</span><span class="n">cadef</span><span class="o">.</span><span class="n">ECA_NORMAL</span><span class="p">):</span>
        <span class="c1">#: Name of the PV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">name</span>
        <span class="c1">#: True for successful completion, False for error code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ok</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">errorcode</span> <span class="o">==</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ECA_NORMAL</span>
        <span class="c1">#: ECA error code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errorcode</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">errorcode</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;CANothing(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errorcode</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ca_message</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errorcode</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ok</span></div>


<span class="k">def</span> <span class="nf">maybe_throw</span><span class="p">(</span><span class="n">async_function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function decorator for optionally catching exceptions.  Exceptions</span>
<span class="sd">    raised by the wrapped function are normally propagated unchanged, but if</span>
<span class="sd">    throw=False is specified as a keyword argument then the exception is</span>
<span class="sd">    transformed into an ordinary CANothing value!&quot;&quot;&quot;</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">throw_wrapper</span><span class="p">(</span>
        <span class="n">pv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">Timeout</span> <span class="o">=</span> <span class="n">DEFAULT_TIMEOUT</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="n">awaitable</span> <span class="o">=</span> <span class="n">ca_timeout</span><span class="p">(</span><span class="n">async_function</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">pv</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">throw</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">awaitable</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We catch all the expected exceptions, converting them into</span>
            <span class="c1"># CANothing() objects as appropriate.  Any unexpected exceptions</span>
            <span class="c1"># will be raised anyway, which seems fair enough!</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="k">await</span> <span class="n">awaitable</span>
            <span class="k">except</span> <span class="n">CANothing</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">error</span>
            <span class="k">except</span> <span class="n">cadef</span><span class="o">.</span><span class="n">CAException</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">CANothing</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="n">error</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">cadef</span><span class="o">.</span><span class="n">Disconnected</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">CANothing</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ECA_DISCONN</span><span class="p">)</span>

    <span class="c1"># The singledispatch decorator makes a sync wrapper. We need it to be</span>
    <span class="c1"># async so it works with inspect.iscoroutine, so wrap it again</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">async_function</span><span class="p">)</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">call_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">throw_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># But keep the register function and register a signature that includes</span>
    <span class="c1"># the extras we added</span>
    <span class="n">call_wrapper</span><span class="o">.</span><span class="n">register</span> <span class="o">=</span> <span class="n">throw_wrapper</span><span class="o">.</span><span class="n">register</span>
    <span class="n">original_sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">async_function</span><span class="p">)</span>
    <span class="n">throw_parameters</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">throw_wrapper</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="p">[</span>
        <span class="o">*</span><span class="n">original_sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
        <span class="n">throw_parameters</span><span class="p">[</span><span class="s2">&quot;timeout&quot;</span><span class="p">],</span>
        <span class="n">throw_parameters</span><span class="p">[</span><span class="s2">&quot;throw&quot;</span><span class="p">],</span>
    <span class="p">]</span>
    <span class="n">call_wrapper</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">original_sig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">call_wrapper</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">ca_timeout</span><span class="p">(</span><span class="n">awaitable</span><span class="p">:</span> <span class="n">Awaitable</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">Timeout</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Wait for awaitable to complete, with timeout one of:</span>
<span class="sd">    None            Wait forever</span>
<span class="sd">    interval        Wait for this amount of seconds</span>
<span class="sd">    (deadline,)     Wait until this absolute timestamp</span>
<span class="sd">    Convert any timeouts into a CANothing timeout containing the pv name</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Convert (abstimeout,) to relative timeout for asyncio</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">awaitable</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TimeoutError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CANothing</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ECA_TIMEOUT</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">awaitable</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">parallel_timeout</span><span class="p">(</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Return kwargs with a suitable timeout for running in parallel&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;throw&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
        <span class="c1"># told to throw, so remove the timeout as it will be done at the top level</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">in_parallel</span><span class="p">(</span>
    <span class="n">awaitables</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Awaitable</span><span class="p">[</span><span class="n">T</span><span class="p">]],</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;throw&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
        <span class="c1"># timeout at this level, awaitables will not timeout themselves</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;timeout&quot;</span><span class="p">,</span> <span class="n">DEFAULT_TIMEOUT</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ca_timeout</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">awaitables</span><span class="p">),</span> <span class="s2">&quot;Multiple PVs&quot;</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># timeout being done at the level of each awaitable</span>
        <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">awaitables</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>


<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#   Channel object and cache</span>


<span class="k">class</span> <span class="nc">Channel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wraps a single channel access channel object.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__subscriptions&quot;</span><span class="p">,</span>  <span class="c1"># Set of listening subscriptions</span>
        <span class="s2">&quot;__connect_event&quot;</span><span class="p">,</span>  <span class="c1"># Connection event used to notify changes</span>
        <span class="s2">&quot;__event_loop&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_as_parameter_&quot;</span><span class="p">,</span>  <span class="c1"># Associated channel access channel handle</span>
    <span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@cadef</span><span class="o">.</span><span class="n">connection_handler</span>
    <span class="k">def</span> <span class="nf">on_ca_connect</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;This routine is called every time the connection status of the</span>
<span class="sd">        channel changes.  This is called directly from channel access, which</span>
<span class="sd">        means that user callbacks should not be called directly.&quot;&quot;&quot;</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ca_puser</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">chid</span><span class="p">)</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__event_loop</span><span class="o">.</span><span class="n">call_soon_threadsafe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_ca_connect_</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_ca_connect_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cadef</span><span class="o">.</span><span class="n">CA_OP_CONN_UP</span><span class="p">,</span> <span class="n">cadef</span><span class="o">.</span><span class="n">CA_OP_CONN_DOWN</span><span class="p">]</span>
        <span class="n">connected</span> <span class="o">=</span> <span class="n">op</span> <span class="o">==</span> <span class="n">cadef</span><span class="o">.</span><span class="n">CA_OP_CONN_UP</span>

        <span class="k">if</span> <span class="n">connected</span><span class="p">:</span>
            <span class="c1"># Trigger wakeup of all listeners</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__connect_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__connect_event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># Inform all the connected subscriptions</span>
        <span class="k">for</span> <span class="n">subscription</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__subscriptions</span><span class="p">:</span>
            <span class="n">subscription</span><span class="o">.</span><span class="n">_on_connect</span><span class="p">(</span><span class="n">connected</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a channel access channel with the given name.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__subscriptions</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Subscription</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__connect_event</span> <span class="o">=</span> <span class="n">ValueEvent</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__event_loop</span> <span class="o">=</span> <span class="n">loop</span>

        <span class="n">chid</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">()</span>
        <span class="n">cadef</span><span class="o">.</span><span class="n">ca_create_channel</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ca_connect</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">chid</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Setting this allows a channel object to autoconvert into the chid</span>
        <span class="c1"># when passed to ca_ functions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_as_parameter_</span> <span class="o">=</span> <span class="n">chid</span><span class="o">.</span><span class="n">value</span>
        <span class="n">_flush_io</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_purge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Forcible purge of channel.  As well as closing the channels,</span>
<span class="sd">        ensures that all subscriptions attached to the channel are also</span>
<span class="sd">        closed.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">subscription</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__subscriptions</span><span class="p">):</span>
            <span class="n">subscription</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">cadef</span><span class="o">.</span><span class="n">ca_clear_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_parameter_</span>

    <span class="k">def</span> <span class="nf">_add_subscription</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subscription</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the given subscription to the list of receivers of connection</span>
<span class="sd">        notification.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__subscriptions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">subscription</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove_subscription</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subscription</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the given subscription from the list of receivers.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__subscriptions</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">subscription</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Waits for the channel to become connected if not already connected.&quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">__connect_event</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">ChannelCache</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A cache of all open channels.  If a channel is not present in the</span>
<span class="sd">    cache it is automatically opened.  The cache needs to be purged to</span>
<span class="sd">    ensure a clean shutdown.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">AbstractEventLoop</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__channels</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loop</span>

    <span class="k">def</span> <span class="nf">get_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Channel</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># When the channel already exists, just return that</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__channels</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Have to create a new channel</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">Channel</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__channels</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span>
            <span class="k">return</span> <span class="n">channel</span>

    <span class="k">def</span> <span class="nf">purge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Purges all the channels in the cache: closes them right now.  Will</span>
<span class="sd">        cause other channel access to fail, so only to be done on shutdown.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__channels</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">channel</span><span class="o">.</span><span class="n">_purge</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__channels</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>


<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#   camonitor</span>


<div class="viewcode-block" id="Subscription"><a class="viewcode-back" href="../../api.html#aioca.Subscription">[docs]</a><span class="k">class</span> <span class="nc">Subscription</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A Subscription object wraps a single channel access subscription, and</span>
<span class="sd">    notifies all updates through an event queue.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;name&quot;</span><span class="p">,</span>  <span class="c1"># Name of the PV subscribed to</span>
        <span class="s2">&quot;callback&quot;</span><span class="p">,</span>  <span class="c1"># The user callback function</span>
        <span class="s2">&quot;dbr_to_value&quot;</span><span class="p">,</span>  <span class="c1"># Conversion from dbr</span>
        <span class="s2">&quot;channel&quot;</span><span class="p">,</span>  <span class="c1"># The associated channel object</span>
        <span class="s2">&quot;state&quot;</span><span class="p">,</span>  <span class="c1"># Whether the subscription is active</span>
        <span class="s2">&quot;dropped_callbacks&quot;</span><span class="p">,</span>  <span class="c1"># How many values have been dropped without callback</span>
        <span class="s2">&quot;_as_parameter_&quot;</span><span class="p">,</span>  <span class="c1"># Associated channel access subscription handle</span>
        <span class="s2">&quot;all_updates&quot;</span><span class="p">,</span>  <span class="c1"># True iff all updates delivered without merging</span>
        <span class="s2">&quot;notify_disconnect&quot;</span><span class="p">,</span>  <span class="c1"># Whether to report disconnect events</span>
        <span class="s2">&quot;__values&quot;</span><span class="p">,</span>  <span class="c1"># Most recent updates from event handler</span>
        <span class="s2">&quot;__lock&quot;</span><span class="p">,</span>  <span class="c1"># Taken while a callback is running</span>
        <span class="s2">&quot;__event_loop&quot;</span><span class="p">,</span>  <span class="c1"># The event loop the caller created this from</span>
        <span class="s2">&quot;__tasks&quot;</span><span class="p">,</span>  <span class="c1"># Tasks that have been spawned from within asyncio</span>
    <span class="p">]</span>

    <span class="c1"># Subscription state values:</span>
    <span class="n">OPENING</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Subscription not complete yet</span>
    <span class="n">OPEN</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Normally active</span>
    <span class="n">CLOSED</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Closed but not yet deleted</span>

    <span class="c1"># Mapping from format to event mask for default events</span>
    <span class="n">__default_events</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">dbr</span><span class="o">.</span><span class="n">FORMAT_RAW</span><span class="p">:</span> <span class="n">cadef</span><span class="o">.</span><span class="n">DBE_VALUE</span><span class="p">,</span>
        <span class="n">dbr</span><span class="o">.</span><span class="n">FORMAT_TIME</span><span class="p">:</span> <span class="n">cadef</span><span class="o">.</span><span class="n">DBE_VALUE</span> <span class="o">|</span> <span class="n">cadef</span><span class="o">.</span><span class="n">DBE_ALARM</span><span class="p">,</span>
        <span class="n">dbr</span><span class="o">.</span><span class="n">FORMAT_CTRL</span><span class="p">:</span> <span class="n">cadef</span><span class="o">.</span><span class="n">DBE_VALUE</span> <span class="o">|</span> <span class="n">cadef</span><span class="o">.</span><span class="n">DBE_ALARM</span> <span class="o">|</span> <span class="n">cadef</span><span class="o">.</span><span class="n">DBE_PROPERTY</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@cadef</span><span class="o">.</span><span class="n">event_handler</span>
    <span class="k">def</span> <span class="nf">__on_event</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;This is called each time the subscribed value changes.  As this is</span>
<span class="sd">        called asynchronously, a signal must be queued for later dispatching</span>
<span class="sd">        to the monitoring user.&quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">usr</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">args</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ECA_NORMAL</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Subscription </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> got bad status </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># Good data: extract value from the dbr. Note that this can fail</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dbr_to_value</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">raw_dbr</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">count</span><span class="p">))</span>
            <span class="c1"># This signals update merging should occur</span>
            <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># Something went wrong, insert it into the processing chain</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__event_loop</span><span class="o">.</span><span class="n">call_soon_threadsafe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__create_signal_task</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__create_signal_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__signal</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrapper for performing callbacks safely: only performs the callback</span>
<span class="sd">        if the subscription is open and reports and handles any exceptions that</span>
<span class="sd">        might arise.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">CLOSED</span><span class="p">:</span>
            <span class="c1"># We have closed this subscription, don&#39;t callback on pending values</span>
            <span class="k">return</span>
        <span class="c1"># Take the lock so two callbacks can&#39;t run at once</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Consume a single value from the queue</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__values</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c1"># Deque has overflowed, count and return</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dropped_callbacks</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">return</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="c1"># This should only happen if the asynchronous callback</span>
                    <span class="c1"># caught an exception for us to re-raise here.</span>
                    <span class="k">raise</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isawaitable</span><span class="p">(</span><span class="n">ret</span><span class="p">):</span>
                        <span class="k">await</span> <span class="n">ret</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># We try and be robust about exceptions in handlers, but to</span>
                <span class="c1"># prevent a perpetual storm of exceptions, we close the</span>
                <span class="c1"># subscription after reporting the problem.</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Subscription </span><span class="si">%s</span><span class="s2"> callback raised exception&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Subscription </span><span class="si">%s</span><span class="s2"> closed&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_on_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connected</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is called each time the connection state of the underlying</span>
<span class="sd">        channel changes.  It is called synchronously.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">connected</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">notify_disconnect</span><span class="p">:</span>
            <span class="c1"># Channel has become disconnected: tell the subscriber.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__create_signal_task</span><span class="p">(</span><span class="n">CANothing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ECA_DISCONN</span><span class="p">))</span>

<div class="viewcode-block" id="Subscription.close"><a class="viewcode-back" href="../../api.html#aioca.Subscription.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Closes the subscription and releases any associated resources.</span>
<span class="sd">        Note that no further callbacks will occur on a closed subscription,</span>
<span class="sd">        not even callbacks currently queued for execution.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPEN</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">_remove_subscription</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">cadef</span><span class="o">.</span><span class="n">ca_clear_subscription</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__event_loop</span><span class="o">.</span><span class="n">is_closed</span><span class="p">():</span>
            <span class="n">_flush_io</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tasks</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CLOSED</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Awaitable</span><span class="p">]],</span>
        <span class="n">events</span><span class="p">:</span> <span class="n">Dbe</span><span class="p">,</span>
        <span class="n">datatype</span><span class="p">:</span> <span class="n">Datatype</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">:</span> <span class="n">Format</span><span class="p">,</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">Count</span><span class="p">,</span>
        <span class="n">all_updates</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">notify_disconnect</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">connect_timeout</span><span class="p">:</span> <span class="n">Timeout</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify_disconnect</span> <span class="o">=</span> <span class="n">notify_disconnect</span>
        <span class="c1">#: The number of updates that have been dropped as they happened</span>
        <span class="c1">#: while another callback was in progress</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dropped_callbacks</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__event_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__values</span><span class="p">:</span> <span class="n">Deque</span><span class="p">[</span><span class="n">AugmentedValue</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span>
            <span class="n">maxlen</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">all_updates</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

        <span class="c1"># If events not specified then compute appropriate default corresponding</span>
        <span class="c1"># to the requested format.</span>
        <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__default_events</span><span class="p">[</span><span class="nb">format</span><span class="p">]</span>

        <span class="c1"># Trigger channel connection if channel not already known.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">get_channel</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Spawn the actual task of creating the subscription into the</span>
        <span class="c1"># background, as we may have to wait for the channel to become</span>
        <span class="c1"># connected.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPENING</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tasks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__create_subscription</span><span class="p">(</span>
                    <span class="n">events</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">connect_timeout</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">]</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__wait_for_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Wait for channel to be connected</span>
            <span class="k">await</span> <span class="n">ca_timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">wait</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CANothing</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Connection timeout.  Let the caller know and now just block</span>
            <span class="c1"># until we connect (if ever).  Note that in this case the caller</span>
            <span class="c1"># is notified even if notify_disconnect=False is set.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__create_signal_task</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__create_subscription</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">connect_timeout</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the channel subscription with the specified parameters:</span>
<span class="sd">        event mask, datatype and format, array count.  Waits for the channel</span>
<span class="sd">        to become connected.&quot;&quot;&quot;</span>

        <span class="c1"># Need to first wait for the channel to connect before we can do</span>
        <span class="c1"># anything else. This will either succeed, or wait forever, raising</span>
        <span class="c1"># if close() is called</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">__wait_for_channel</span><span class="p">(</span><span class="n">connect_timeout</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPEN</span>

        <span class="c1"># Treat a negative count as a request for the complete data</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ca_element_count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>

        <span class="c1"># Connect to the channel to be kept informed of connection updates.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">_add_subscription</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Convert the datatype request into the subscription datatype.</span>
        <span class="n">dbrcode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbr_to_value</span> <span class="o">=</span> <span class="n">dbr</span><span class="o">.</span><span class="n">type_to_dbr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>

        <span class="c1"># Finally create the subscription with all the requested properties</span>
        <span class="c1"># and hang onto the returned event id as our implicit ctypes</span>
        <span class="c1"># parameter.</span>
        <span class="n">event_id</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">()</span>
        <span class="n">cadef</span><span class="o">.</span><span class="n">ca_create_subscription</span><span class="p">(</span>
            <span class="n">dbrcode</span><span class="p">,</span>
            <span class="n">count</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span>
            <span class="n">events</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__on_event</span><span class="p">,</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">event_id</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">_flush_io</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_as_parameter_</span> <span class="o">=</span> <span class="n">event_id</span><span class="o">.</span><span class="n">value</span></div>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">camonitor</span><span class="p">(</span>
    <span class="n">pv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Awaitable</span><span class="p">]],</span>
    <span class="n">events</span><span class="p">:</span> <span class="n">Dbe</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">datatype</span><span class="p">:</span> <span class="n">Datatype</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="n">Format</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">count</span><span class="p">:</span> <span class="n">Count</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">all_updates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">notify_disconnect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">connect_timeout</span><span class="p">:</span> <span class="n">Timeout</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Subscription</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># pragma: no cover</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">camonitor</span><span class="p">(</span>
    <span class="n">pv</span><span class="p">:</span> <span class="n">PVs</span><span class="p">,</span>
    <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Awaitable</span><span class="p">]],</span>
    <span class="n">events</span><span class="p">:</span> <span class="n">Dbe</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">datatype</span><span class="p">:</span> <span class="n">Datatype</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="n">Format</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">count</span><span class="p">:</span> <span class="n">Count</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">all_updates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">notify_disconnect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">connect_timeout</span><span class="p">:</span> <span class="n">Timeout</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Subscription</span><span class="p">]:</span>
    <span class="o">...</span>  <span class="c1"># pragma: no cover</span>


<div class="viewcode-block" id="camonitor"><a class="viewcode-back" href="../../api.html#aioca.camonitor">[docs]</a><span class="k">def</span> <span class="nf">camonitor</span><span class="p">(</span>
    <span class="n">pv</span><span class="p">,</span>
    <span class="n">callback</span><span class="p">,</span>
    <span class="n">events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">datatype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="nb">format</span><span class="o">=</span><span class="n">dbr</span><span class="o">.</span><span class="n">FORMAT_RAW</span><span class="p">,</span>
    <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">all_updates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">notify_disconnect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">connect_timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a subscription to one or more PVs</span>

<span class="sd">    Args:</span>
<span class="sd">        callback: Regular function or async function</span>
<span class="sd">        events: Bit-wise or of `Dbe` types to notify about. If not given the</span>
<span class="sd">            default mask depends on the requested format</span>
<span class="sd">        datatype: Override `Datatype` to a non-native type</span>
<span class="sd">        format: Request extra `Format` fields</span>
<span class="sd">        count: Request a specific element `Count` in an array</span>
<span class="sd">        all_updates: If True then every update received from channel</span>
<span class="sd">            access will trigger a callback, otherwise any updates received</span>
<span class="sd">            during the previous callback will be merged into the most recent</span>
<span class="sd">            value, incrementing `Subscription.dropped_callbacks`</span>
<span class="sd">        notify_disconnect: If True then IOC disconnect events will be reported</span>
<span class="sd">            by calling the callback with a `CANothing` error with .ok False,</span>
<span class="sd">            otherwise only valid values will be passed to the callback routine</span>
<span class="sd">        connect_timeout: If specified then the camonitor will report a</span>
<span class="sd">            disconnection event after the specified interval if connection</span>
<span class="sd">            has not completed by this time. Note that this notification will be</span>
<span class="sd">            made even if notify_disconnect is False, and that if the PV</span>
<span class="sd">            subsequently connects it will update as normal.</span>

<span class="sd">    Returns:</span>
<span class="sd">        `Subscription` for single PV or [`Subscription`] for a list of PVs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;pv&quot;</span><span class="p">),</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Subscription</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">make_cb</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">cb</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;callback&quot;</span><span class="p">)):</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">cb</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

        <span class="n">subs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Subscription</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">make_cb</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pv</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">subs</span></div>


<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#   caget</span>


<span class="nd">@cadef</span><span class="o">.</span><span class="n">event_handler</span>
<span class="k">def</span> <span class="nf">_caget_event_handler</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;This will be called when a caget request completes, either with a</span>
<span class="sd">    brand new data value or with failure.  The result is communicated back</span>
<span class="sd">    to the original caller.&quot;&quot;&quot;</span>

    <span class="c1"># We are called exactly once, so can consume the context right now.  Note</span>
    <span class="c1"># that we have to do some manual reference counting on the user context,</span>
    <span class="c1"># as this is a python object that is invisible to the C api.</span>
    <span class="n">pv</span><span class="p">,</span> <span class="n">dbr_to_value</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">event_loop</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">usr</span>
    <span class="n">ctypes</span><span class="o">.</span><span class="n">pythonapi</span><span class="o">.</span><span class="n">Py_DecRef</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">usr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ECA_NORMAL</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">dbr_to_value</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">raw_dbr</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">e</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">CANothing</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">call_soon_threadsafe</span><span class="p">(</span><span class="n">done</span><span class="o">.</span><span class="n">set</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="nd">@overload</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">caget</span><span class="p">(</span>
    <span class="n">pv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">datatype</span><span class="p">:</span> <span class="n">Datatype</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="n">Format</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">count</span><span class="p">:</span> <span class="n">Count</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">timeout</span><span class="p">:</span> <span class="n">Timeout</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">throw</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AugmentedValue</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># pragma: no cover</span>


<span class="nd">@overload</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">caget</span><span class="p">(</span>
    <span class="n">pvs</span><span class="p">:</span> <span class="n">PVs</span><span class="p">,</span>
    <span class="n">datatype</span><span class="p">:</span> <span class="n">Datatype</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="n">Format</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">count</span><span class="p">:</span> <span class="n">Count</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">timeout</span><span class="p">:</span> <span class="n">Timeout</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">throw</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">AugmentedValue</span><span class="p">]:</span>
    <span class="o">...</span>  <span class="c1"># pragma: no cover</span>


<div class="viewcode-block" id="caget"><a class="viewcode-back" href="../../api.html#aioca.caget">[docs]</a><span class="nd">@maybe_throw</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">caget</span><span class="p">(</span><span class="n">pv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">dbr</span><span class="o">.</span><span class="n">FORMAT_RAW</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retrieves an `AugmentedValue` from one or more PVs.</span>

<span class="sd">    Args:</span>
<span class="sd">        datatype: Override `Datatype` to a non-native type</span>
<span class="sd">        format: Request extra `Format` fields</span>
<span class="sd">        count: Request a specific element `Count` in an array</span>
<span class="sd">        timeout: After how long should caget `Timeout`</span>
<span class="sd">        throw: If False then return `CANothing` instead of raising an exception</span>

<span class="sd">    Returns:</span>
<span class="sd">        `AugmentedValue` for single PV or [`AugmentedValue`] for a list of PVs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: docstring refers to both this function and caget_array below</span>
    <span class="c1"># Retrieve the requested channel and ensure it&#39;s connected.</span>
    <span class="n">channel</span> <span class="o">=</span> <span class="n">get_channel</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">channel</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="c1"># A count of zero will be treated by EPICS in a version dependent manner,</span>
    <span class="c1"># either returning the entire waveform (equivalent to count=-1) or a data</span>
    <span class="c1"># dependent waveform length.</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Treat negative count request as request for fixed underlying channel</span>
        <span class="c1"># size.</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ca_element_count</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Need to ensure we don&#39;t ask for more than the channel can provide as</span>
        <span class="c1"># otherwise may get API error.</span>
        <span class="n">count</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ca_element_count</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>

    <span class="c1"># Assemble the callback context.  Note that we need to explicitly</span>
    <span class="c1"># increment the reference count so that the context survives until the</span>
    <span class="c1"># callback routine gets to see it.</span>
    <span class="n">dbrcode</span><span class="p">,</span> <span class="n">dbr_to_value</span> <span class="o">=</span> <span class="n">dbr</span><span class="o">.</span><span class="n">type_to_dbr</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>
    <span class="n">done</span> <span class="o">=</span> <span class="n">ValueEvent</span><span class="p">[</span><span class="n">AugmentedValue</span><span class="p">]()</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="n">dbr_to_value</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="n">ctypes</span><span class="o">.</span><span class="n">pythonapi</span><span class="o">.</span><span class="n">Py_IncRef</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

    <span class="c1"># Perform the actual put as a non-blocking operation: we wait to be</span>
    <span class="c1"># informed of completion, or time out.</span>
    <span class="n">cadef</span><span class="o">.</span><span class="n">ca_array_get_callback</span><span class="p">(</span>
        <span class="n">dbrcode</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">_caget_event_handler</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">_flush_io</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">done</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="nd">@caget</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
<span class="nd">@caget</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">caget_array</span><span class="p">(</span><span class="n">pvs</span><span class="p">:</span> <span class="n">PVs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Spawn a separate caget task for each pv: this allows them to complete</span>
    <span class="c1"># in parallel which can speed things up considerably.</span>
    <span class="n">coros</span> <span class="o">=</span> <span class="p">[</span><span class="n">caget</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="o">**</span><span class="n">parallel_timeout</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span> <span class="k">for</span> <span class="n">pv</span> <span class="ow">in</span> <span class="n">pvs</span><span class="p">]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">in_parallel</span><span class="p">(</span><span class="n">coros</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span>


<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#   caput</span>


<span class="nd">@cadef</span><span class="o">.</span><span class="n">event_handler</span>
<span class="k">def</span> <span class="nf">_caput_event_handler</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Event handler for caput with callback completion.  Returns status</span>
<span class="sd">    code to caller.&quot;&quot;&quot;</span>

    <span class="c1"># This is called exactly once when a caput request completes.  Extract</span>
    <span class="c1"># our context information and discard the context immediately.</span>
    <span class="n">pv</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">event_loop</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">usr</span>
    <span class="n">ctypes</span><span class="o">.</span><span class="n">pythonapi</span><span class="o">.</span><span class="n">Py_DecRef</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">usr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ECA_NORMAL</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">CANothing</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">call_soon_threadsafe</span><span class="p">(</span><span class="n">done</span><span class="o">.</span><span class="n">set</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="nd">@overload</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">caput</span><span class="p">(</span>
    <span class="n">pv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="n">datatype</span><span class="p">:</span> <span class="n">Datatype</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">wait</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">timeout</span><span class="p">:</span> <span class="n">Timeout</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">throw</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CANothing</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># pragma: no cover</span>


<span class="nd">@overload</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">caput</span><span class="p">(</span>
    <span class="n">pvs</span><span class="p">:</span> <span class="n">PVs</span><span class="p">,</span>
    <span class="n">values</span><span class="p">,</span>
    <span class="n">repeat_value</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">datatype</span><span class="p">:</span> <span class="n">Datatype</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">wait</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">timeout</span><span class="p">:</span> <span class="n">Timeout</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="n">throw</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">CANothing</span><span class="p">]:</span>
    <span class="o">...</span>  <span class="c1"># pragma: no cover</span>


<div class="viewcode-block" id="caput"><a class="viewcode-back" href="../../api.html#aioca.caput">[docs]</a><span class="nd">@maybe_throw</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">caput</span><span class="p">(</span><span class="n">pv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">datatype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Writes values to one or more PVs</span>

<span class="sd">    If a list of PVs is given, then normally value will have the same length</span>
<span class="sd">    and value[i] is written to pv[i]. If value is a scalar or</span>
<span class="sd">    repeat_value=True then the same value is written to all PVs.</span>

<span class="sd">    Args:</span>
<span class="sd">        repeat_value: If True and a list of PVs is given, write the same</span>
<span class="sd">            value to every PV.</span>
<span class="sd">        datatype: Override `Datatype` to a non-native type</span>
<span class="sd">        wait: Do a caput with callback, waiting for completion</span>
<span class="sd">        timeout: After how long should a caput with wait=True `Timeout`</span>
<span class="sd">        throw: If False then return `CANothing` instead of raising an exception</span>

<span class="sd">    Returns:</span>
<span class="sd">        `CANothing` for single PV or [`CANothing`] for a list of PVs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Connect to the channel and wait for connection to complete.</span>
    <span class="n">channel</span> <span class="o">=</span> <span class="n">get_channel</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">channel</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="c1"># Note: the unused value returned below needs to be retained so that</span>
    <span class="c1"># dbr_array, a pointer to C memory, has the right lifetime: it has to</span>
    <span class="c1"># survive until ca_array_put[_callback] has been called.</span>
    <span class="n">dbrtype</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">dbr_array</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dbr</span><span class="o">.</span><span class="n">value_to_dbr</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wait</span><span class="p">:</span>
        <span class="c1"># Assemble the callback context and give it an extra reference count</span>
        <span class="c1"># to keep it alive until the callback handler sees it.</span>
        <span class="n">done</span> <span class="o">=</span> <span class="n">ValueEvent</span><span class="p">[</span><span class="kc">None</span><span class="p">]()</span>
        <span class="n">context</span> <span class="o">=</span> <span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">())</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">pythonapi</span><span class="o">.</span><span class="n">Py_IncRef</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

        <span class="c1"># caput with callback requested: need to wait for response from</span>
        <span class="c1"># server before returning.</span>
        <span class="n">cadef</span><span class="o">.</span><span class="n">ca_array_put_callback</span><span class="p">(</span>
            <span class="n">dbrtype</span><span class="p">,</span>
            <span class="n">count</span><span class="p">,</span>
            <span class="n">channel</span><span class="p">,</span>
            <span class="n">dbr_array</span><span class="p">,</span>
            <span class="n">_caput_event_handler</span><span class="p">,</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="n">context</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">_flush_io</span><span class="p">()</span>
        <span class="k">await</span> <span class="n">done</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Asynchronous caput, just do it now.</span>
        <span class="n">cadef</span><span class="o">.</span><span class="n">ca_array_put</span><span class="p">(</span><span class="n">dbrtype</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">dbr_array</span><span class="p">)</span>
        <span class="n">_flush_io</span><span class="p">()</span>

    <span class="c1"># Return a success code for compatibility with throw=False code.</span>
    <span class="k">return</span> <span class="n">CANothing</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span></div>


<span class="nd">@caput</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
<span class="nd">@caput</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">caput_array</span><span class="p">(</span><span class="n">pvs</span><span class="p">:</span> <span class="n">PVs</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">repeat_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Bring the arrays of pvs and values into alignment.</span>
    <span class="k">if</span> <span class="n">repeat_value</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># If repeat_value is requested or the value is a string then we treat</span>
        <span class="c1"># it as a single value.</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># If the value can&#39;t be treated as a list then again we treat it</span>
            <span class="c1"># as a single value</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvs</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pvs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="s2">&quot;PV and value lists must match in length&quot;</span>
    <span class="n">coros</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">caput</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">parallel_timeout</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span> <span class="k">for</span> <span class="n">pv</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pvs</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">in_parallel</span><span class="p">(</span><span class="n">coros</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span>


<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#   connect</span>


<div class="viewcode-block" id="CAInfo"><a class="viewcode-back" href="../../api.html#aioca.CAInfo">[docs]</a><span class="k">class</span> <span class="nc">CAInfo</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Object representing the information returned from `cainfo`&quot;&quot;&quot;</span>

    <span class="c1">#: Converts `state` into a printable description of the connection state.</span>
    <span class="n">state_strings</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;never connected&quot;</span><span class="p">,</span> <span class="s2">&quot;previously connected&quot;</span><span class="p">,</span> <span class="s2">&quot;connected&quot;</span><span class="p">,</span> <span class="s2">&quot;closed&quot;</span><span class="p">]</span>
    <span class="c1">#: Textual descriptions of the possible channel data types, can be</span>
    <span class="c1">#: used to convert `datatype` into a printable string</span>
    <span class="n">datatype_strings</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;string&quot;</span><span class="p">,</span>
        <span class="s2">&quot;short&quot;</span><span class="p">,</span>
        <span class="s2">&quot;float&quot;</span><span class="p">,</span>
        <span class="s2">&quot;enum&quot;</span><span class="p">,</span>
        <span class="s2">&quot;char&quot;</span><span class="p">,</span>
        <span class="s2">&quot;long&quot;</span><span class="p">,</span>
        <span class="s2">&quot;double&quot;</span><span class="p">,</span>
        <span class="s2">&quot;no access&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">Channel</span><span class="p">):</span>
        <span class="c1">#: True iff the channel was successfully connected</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ok</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1">#: The name of the PV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">pv</span>
        <span class="c1">#: State of channel as an integer. Look up ``state_strings[state]``</span>
        <span class="c1">#: for textual description.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ca_state</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="c1">#: Host name and port of server providing this PV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">host</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ca_host_name</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="c1">#: True iff read access to this PV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ca_read_access</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="c1">#: True iff write access to this PV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ca_write_access</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">cadef</span><span class="o">.</span><span class="n">cs_conn</span><span class="p">:</span>
            <span class="c1">#: Data count of this channel</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ca_element_count</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
            <span class="c1">#: Underlying channel datatype as `Dbr` value. Look up</span>
            <span class="c1">#: ``datatype_strings[datatype]`` for textual description.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ca_field_type</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span> <span class="o">=</span> <span class="mi">7</span>  <span class="c1"># DBF_NO_ACCESS</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2">:</span>
<span class="s2">    State: </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">    Host: </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">    Access: </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">    Data type: </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">    Count: </span><span class="si">%d</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_strings</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">host</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datatype_strings</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
        <span class="p">)</span></div>


<span class="nd">@overload</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span>
    <span class="n">pv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wait</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">Timeout</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span> <span class="n">throw</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CANothing</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># pragma: no cover</span>


<span class="nd">@overload</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span>
    <span class="n">pv</span><span class="p">:</span> <span class="n">PVs</span><span class="p">,</span> <span class="n">wait</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">Timeout</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span> <span class="n">throw</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">CANothing</span><span class="p">]:</span>
    <span class="o">...</span>  <span class="c1"># pragma: no cover</span>


<div class="viewcode-block" id="connect"><a class="viewcode-back" href="../../api.html#aioca.connect">[docs]</a><span class="nd">@maybe_throw</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">pv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Establishes a connection to one or more PVs</span>

<span class="sd">    A single PV or a list of PVs can be given. This does not normally need to be</span>
<span class="sd">    called, as the ca...() routines will establish their own connections as</span>
<span class="sd">    required, but after a successful connection we can guarantee that</span>
<span class="sd">    caput(..., wait=False) will complete immediately without suspension.</span>

<span class="sd">    This routine can safely be called repeatedly without any extra side effects.</span>

<span class="sd">    Args:</span>
<span class="sd">        wait: If False then queue a connection without waiting for completion</span>
<span class="sd">        timeout: After how long should the connect with wait=True `Timeout`</span>
<span class="sd">        throw: If False then return `CANothing` instead of raising an exception</span>

<span class="sd">    Returns:</span>
<span class="sd">        `CANothing` for single PV or [`CANothing`] for a list of PVs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">channel</span> <span class="o">=</span> <span class="n">get_channel</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wait</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">channel</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">CANothing</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span></div>


<span class="nd">@connect</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
<span class="nd">@connect</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">connect_array</span><span class="p">(</span><span class="n">pvs</span><span class="p">:</span> <span class="n">PVs</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">coros</span> <span class="o">=</span> <span class="p">[</span><span class="n">connect</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="o">**</span><span class="n">parallel_timeout</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span> <span class="k">for</span> <span class="n">pv</span> <span class="ow">in</span> <span class="n">pvs</span><span class="p">]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">in_parallel</span><span class="p">(</span><span class="n">coros</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span>


<span class="nd">@overload</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">cainfo</span><span class="p">(</span>
    <span class="n">pv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wait</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">Timeout</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span> <span class="n">throw</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CAInfo</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># pragma: no cover</span>


<span class="nd">@overload</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">cainfo</span><span class="p">(</span>
    <span class="n">pv</span><span class="p">:</span> <span class="n">PVs</span><span class="p">,</span> <span class="n">wait</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">Timeout</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span> <span class="n">throw</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">CAInfo</span><span class="p">]:</span>
    <span class="o">...</span>  <span class="c1"># pragma: no cover</span>


<div class="viewcode-block" id="cainfo"><a class="viewcode-back" href="../../api.html#aioca.cainfo">[docs]</a><span class="nd">@maybe_throw</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">cainfo</span><span class="p">(</span><span class="n">pv</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a `CAInfo` structure for the given PVs.</span>

<span class="sd">    See the documentation for `connect()` for details of arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">channel</span> <span class="o">=</span> <span class="n">get_channel</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wait</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">channel</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">CAInfo</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span></div>


<span class="nd">@cainfo</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
<span class="nd">@cainfo</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">cainfo_array</span><span class="p">(</span><span class="n">pvs</span><span class="p">:</span> <span class="n">PVs</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">coros</span> <span class="o">=</span> <span class="p">[</span><span class="n">cainfo</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="o">**</span><span class="n">parallel_timeout</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span> <span class="k">for</span> <span class="n">pv</span> <span class="ow">in</span> <span class="n">pvs</span><span class="p">]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">in_parallel</span><span class="p">(</span><span class="n">coros</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span>


<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#   CA Context manager</span>


<span class="k">class</span> <span class="nc">_Context</span><span class="p">:</span>
    <span class="n">created</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_channel_caches</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">AbstractEventLoop</span><span class="p">,</span> <span class="n">ChannelCache</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">purge_channel_caches</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove cached channel connections. This will close all subscriptions&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">channel_cache</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_channel_caches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">channel_cache</span><span class="o">.</span><span class="n">purge</span><span class="p">()</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_channel_caches</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_channel_cache</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">created</span><span class="p">:</span>
            <span class="c1"># EPICS Channel Access event dispatching needs to done with a little</span>
            <span class="c1"># care.  In previous versions the solution was to repeatedly call</span>
            <span class="c1"># ca_pend_event() in polling mode, but this does not appear to be</span>
            <span class="c1"># efficient enough when receiving large amounts of data.  Instead we</span>
            <span class="c1"># enable preemptive Channel Access callbacks, which means we need to</span>
            <span class="c1"># cope with all of our channel access events occuring</span>
            <span class="c1"># asynchronously.</span>
            <span class="n">cadef</span><span class="o">.</span><span class="n">ca_context_create</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">created</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">channel_cache</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_channel_caches</span><span class="p">[</span><span class="n">loop</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Channel from new event loop. Don&#39;t support multiple event loops, so</span>
            <span class="c1"># clear out all the old channels</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">purge_channel_caches</span><span class="p">()</span>
            <span class="n">channel_cache</span> <span class="o">=</span> <span class="n">ChannelCache</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_channel_caches</span><span class="p">[</span><span class="n">loop</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel_cache</span>
        <span class="k">return</span> <span class="n">channel_cache</span>


<span class="n">purge_channel_caches</span> <span class="o">=</span> <span class="n">_Context</span><span class="o">.</span><span class="n">purge_channel_caches</span>


<span class="k">def</span> <span class="nf">get_channel</span><span class="p">(</span><span class="n">pv</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Channel</span><span class="p">:</span>
    <span class="n">channel_cache</span> <span class="o">=</span> <span class="n">_Context</span><span class="o">.</span><span class="n">get_channel_cache</span><span class="p">()</span>
    <span class="n">channel</span> <span class="o">=</span> <span class="n">channel_cache</span><span class="o">.</span><span class="n">get_channel</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">channel</span>


<span class="nd">@atexit</span><span class="o">.</span><span class="n">register</span>
<span class="k">def</span> <span class="nf">_catools_atexit</span><span class="p">():</span>  <span class="c1"># pragma: no cover</span>
    <span class="c1"># On exit we do our best to ensure that channel access shuts down cleanly.</span>
    <span class="c1"># We do this by shutting down all channels and clearing the channel access</span>
    <span class="c1"># context: this should reduce the risk of unexpected errors during</span>
    <span class="c1"># application exit.</span>
    <span class="c1">#    One reason that it&#39;s rather important to do this properly is that we</span>
    <span class="c1"># can&#39;t safely do *any* ca_ calls once ca_context_destroy() is called!</span>
    <span class="n">purge_channel_caches</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">_Context</span><span class="o">.</span><span class="n">created</span><span class="p">:</span>
        <span class="n">cadef</span><span class="o">.</span><span class="n">ca_flush_io</span><span class="p">()</span>
        <span class="n">cadef</span><span class="o">.</span><span class="n">ca_context_destroy</span><span class="p">()</span>


<span class="c1"># Another delicacy arising from relying on asynchronous CA event dispatching is</span>
<span class="c1"># that we need to manually flush IO events such as caget commands.  To ensure</span>
<span class="c1"># that large blocks of channel access activity really are aggregated we used to</span>
<span class="c1"># ensure that ca_flush_io() is only called once in any scheduling cycle, but now</span>
<span class="c1"># we just call it every time</span>
<span class="n">_flush_io</span> <span class="o">=</span> <span class="n">cadef</span><span class="o">.</span><span class="n">ca_flush_io</span>


<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#   Helper function for running async code.</span>


<div class="viewcode-block" id="run"><a class="viewcode-back" href="../../api.html#aioca.run">[docs]</a><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">forever</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convenience function that makes an event loop and runs the async</span>
<span class="sd">    function within it.</span>

<span class="sd">    Args:</span>
<span class="sd">        forever: If True then run the event loop forever, otherwise</span>
<span class="sd">            return on completion of the coro</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="n">t</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">forever</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span>
            <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Diamond Light Source.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>